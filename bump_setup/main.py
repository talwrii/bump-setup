import toml
import sys
import os
import argparse
from tree_sitter import Parser, Language
import re
import tree_sitter_python as tspython

def bump_version_in_code(code, version_str, version_type):
    """
    Bumps the version number (major, minor, patch) in the given version string.
    :param code: The code where version is used (e.g. setup.py or pyproject.toml)
    :param version_str: The current version as a string
    :param version_type: Type of version bump ('major', 'minor', 'patch')
    :return: The updated version string and the modified code
    """
    major, minor, patch = map(int, version_str.split('.'))

    if version_type == "major":
        major += 1
        minor = 0
        patch = 0
    elif version_type == "minor":
        minor += 1
        patch = 0
    elif version_type == "patch":
        patch += 1
    else:
        raise ValueError(version_str)

    new_version = f'{major}.{minor}.{patch}'

    # Update the version string in the code
    new_code = re.sub(rf"['\"]{version_str}['\"]", f"'{new_version}'", code)

    return new_version, new_code


def validate_setuptools_imports(tree, code):
    """
    Validates that the `setup` function is imported from `setuptools` or that `setuptools` is imported.
    :param tree: The syntax tree generated by Tree-sitter.
    :param code: The code of the setup.py file to check for valid imports.
    :return: True if valid, False otherwise.
    """
    import_statements = []

    # Traverse the syntax tree to find all 'import_statement' nodes
    for node in tree.root_node.children:
        if node.type in ('import_from_statement', 'import_statement'):
            import_statements.append(node)

    # Check for "from setuptools import setup" or "import setuptools"
    for node in import_statements:
        # Check if it's a 'from ... import ...' statement
        if node.type == 'import_from_statement':
            # Look for "from setuptools import setup"
            _, module, _, *names = node.children
            if module.text == b'setuptools' and b'setup' in [x.text for x in node.children]:
                return True

        # Check if it's an 'import ...' statement
        if node.type == 'import_statement':
            # Look for "import setuptools"
            if node.children[1].text == b'setuptools':
                return True

    return False


def bump_version(file_path, version_type):
    """
    Bumps the version in a `setup.py` or `pyproject.toml` file based on the version type.
    :param file_path: Path to the setup.py or pyproject.toml file
    :param version_type: Type of version bump ('major', 'minor', 'patch')
    """
    if not os.path.exists(file_path):
        raise ValueError(file_path)

    if file_path.endswith("pyproject.toml"):
        # Handle pyproject.toml
        print(f"Found pyproject.toml. Bumping version...")

        try:
            with open(file_path, 'r') as f:
                toml_data = toml.load(f)
        except Exception as e:
            print(f"Error reading pyproject.toml: {e}")
            sys.exit(1)

        # Extract version from the `[project]` section
        if 'project' in toml_data and 'version' in toml_data['project']:
            version = toml_data['project']['version']
        else:
            print("Error: No version found in pyproject.toml under [project]")
            sys.exit(1)

        # Bump the version
        new_version, new_toml_data = bump_version_in_code(toml.dumps(toml_data), version, version_type)

        # Update the version in the toml data
        toml_data['project']['version'] = new_version

        # Write the updated toml data back
        try:
            with open(file_path, 'w') as f:
                toml.dump(toml_data, f)
        except Exception as e:
            print(f"Error writing pyproject.toml: {e}")
            sys.exit(1)

        print(f"Version bumped to {new_version} in pyproject.toml")

    elif file_path.endswith("setup.py"):
        # Handle setup.py using Tree-sitter
        print(f"Found setup.py. Bumping version...")

        try:
            with open(file_path, 'r') as f:
                code = f.read()
        except Exception as e:
            print(f"Error reading setup.py: {e}")
            sys.exit(1)

        # Parse setup.py using Tree-sitter
        parser = Parser()
        parser.language = Language(tspython.language())
        tree = parser.parse(bytes(code, "utf8"))

        # Validate that setup is imported from setuptools
        if not validate_setuptools_imports(tree, code):
            raise Exception("Setuptools not used correctly")

        # Look for the setup function call and its keyword arguments
        version_node = None
        for node in tree.root_node.children:
            if node.type == 'expression_statement':
                for node in node.children:
                    if node.type == "call" and node.children[0].text in (b'setup', b'setuptools.setup'):
                        for node in node.children:
                            if node.type == 'argument_list':
                                for node in node.children:
                                    if node.type == 'keyword_argument':
                                        if node.children[0].text == b'version':
                                            version_node = node
                                            break


        if version_node is None:
            raise Exception('No version is set')

        if version_node.children[2].type != "string":
            raise Exception('Version is not a string literal')
        version_str = version_node.children[2].children[1].text.decode('utf8')

        # Bump the version
        new_version, new_code = bump_version_in_code(code, version_str, version_type)

        # Write the updated code back to the file
        try:
            with open(file_path, 'w') as f:
                f.write(new_code)
        except Exception as e:
            print(f"Error writing setup.py: {e}")
            sys.exit(1)

        print(f"Version bumped to {new_version} in setup.py")

    else:
        raise Exception(f"Unsupported file type: {file_path}")


def main():
    # Set up argparse to handle command-line arguments
    parser = argparse.ArgumentParser(description="Bump version in setup.py or pyproject.toml")
    parser.add_argument(
        "version_type",
        choices=["major", "minor", "patch"],
        help="Type of version bump (major, minor, patch)"
    )

    args = parser.parse_args()

    # Automatically detect which file to process
    if os.path.exists("setup.py"):
        bump_version("setup.py", args.version_type)
    elif os.path.exists("pyproject.toml"):
        bump_version("pyproject.toml", args.version_type)
    else:
        print("Error: Neither setup.py nor pyproject.toml was found in the current directory.")
        sys.exit(1)


if __name__ == "__main__":
    main()
